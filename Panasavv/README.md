![](RackMultipart20201122-4-t5598z_html_20e7695e23e721c1.gif)
ΑΡΙΣΤΟΤΕΛΕΙΟ ΠΑΝΕΠΙΣΤΗΜΙΟ ΘΕΣΣΑΛΟΝΙΚΗΣ

ΠΟΛΥΤΕΧΝΙΚΗ ΣΧΟΛΗ

ΤΜΗΜΑ ΗΛΕΚΤΡΟΛΟΓΩΝ ΜΗΧΑΝΙΚΩΝ &amp; ΜΗΧΑΝΙΚΩΝ ΥΠΟΛΟΓΙΣΤΩΝ

# **Αρχιτεκτονική Προηγμένων Υπολογιστών**

## 1 η Εργαστηριακή Άσκηση

Παναγιώτης Σαββίδης

8094

ΘΕΣΣΑΛΟΝΙΚΗ 2020

1.

**CPU types:**
 i) Atomic Simple CPU
 ii) Minor CPU
 iii) HPI CPU

Από τις παραπάνω CPU τελικά χρησιμοποιήσαμε την **Minor**

**Voltage\_Domain** = 3.3V (by default)
**Clock speed** = 1GHz (by default)
**CPU cluster Voltage** = 1.2V (by default)

**Number of Cores** = 1 (by default)

**Caches** : Εφόσον επιλέξαμε την Minor CPU θα έχουμε **L1** και **L2** caches

Μνήμη : Στην εντολή που τρέξαμε δεν προσδιορίσαμε κάτι για την μνήμη (μέσω της εντολής –mem) συνεπώς θα ληφθούν οι default τιμές.
**mem-type** = DDR3\_1600\_8x8
**mem-channels** = 2
**mem-ranks** = None
**mem-size** = 2GB
**membus** = SystemXBar()

1. _A ![](RackMultipart20201122-4-t5598z_html_efa8ee00c207c888.jpg) )_

Το **cpu**** type**βρίσκεται στη γραμμή 65

![](RackMultipart20201122-4-t5598z_html_459df04d381d61d.jpg)

Στη γραμμή 1652 φαίνεται το **Voltage**** Domain**.

![](RackMultipart20201122-4-t5598z_html_6d397abdcdd6358b.jpg)

Στη γραμμή 44 βρίσκουμε το **Clock**** Domain**.

Το 1000 αναφέρεται στα ticks, άρα έχουμε

![](RackMultipart20201122-4-t5598z_html_6343c37c2c900f2.jpg)

Στη γραμμή 1339 υπάρχει το **Voltage****.**

![](RackMultipart20201122-4-t5598z_html_bd0f31457fd306a6.jpg) ![](RackMultipart20201122-4-t5598z_html_af1936502a75aba7.jpg) ![](RackMultipart20201122-4-t5598z_html_6f2b4d4e4badb514.jpg) 
Στη γραμμή 58 βρίσκουμε το **cpu**** Clock ****.**
 Με αντίστοιχο τρόπο όπως και πιο πάνω , έχουμε 4GHz


 Στη γραμμή 1610 υπάρχει το **membus**** type**.

Τέλος στη σειρά 113 βρίσκεται το **number**** of ****Cores**.


_B__)_
 Το συνολικό νούμερο των **committed**** Instructions** φαίνονται στις γραμμές 14 και 15. ![](RackMultipart20201122-4-t5598z_html_13dc36bcebf61525.jpg)

Αυτή η διαφορά εμφανίζεται γιατί στη δεύτερη σειρά υπολογίζονται και τα microoperations.

_C__)_
 Ο συνολικός αριθμός **που προσπελάστηκε η**  **L**** 2 **** cache **φαίνεται στη σειρά 493 στο** stats ****.**** txt**. ![](RackMultipart20201122-4-t5598z_html_6a4781aba2d515d8.jpg)


 Αν αυτό το νούμερο δεν μας δινόταν, θα μπορούσαμε να το υπολογίσουμε από το άθροισμα των σειρών 556,574 και 594, όπως φαίνεται παρακάτω.
 ![](RackMultipart20201122-4-t5598z_html_a0353886942e12e.jpg) ![](RackMultipart20201122-4-t5598z_html_9a2886e9b808fd95.jpg) ![](RackMultipart20201122-4-t5598z_html_fd748152eed452e5.jpg)

**3.**

**MinorCPU**** :**
 Αυτό το μοντέλο CPU, όπως μας ζητήθηκε, είναι ένα in-order μοντέλο επεξεργαστή. Χρησιμοποιείται κυρίως διότι επιτρέπει την οπτικοποίηση της θέσης μιας εντολής μέσα στο pipeline διαμέσω του MinorTrace/minorview.pyformat/tool. Η MinorCPU χρησιμοποιείται για να προσομοιώνει μοντέλα επεξεργαστών με αυστηρή in-order εκτέλεση και να παρέχει μια δομή για μικρο-αρχιτεκτονική συσχέτιση του μοντέλου με μια συγκεκριμένη διαδικασία, όπως έχουμε επιλέξει, που έχει παρόμοιες δυνατότητες με αυτήν που χρησιμοποιούμε.

**AtomicSimpleCPU**** :**
 Το μοντέλο αυτό αποτελεί μια version της SimpleCPU η οποία χρησιμοποιεί atomicmemoryaccesses. Η AtomicSimpleCPU επιλέγει ποια θύρα θα χρησιμοποιήσει έτσι ώστε να έρθει σε επαφή με τη μνήμη και να ενώσει την CPU με την μνήμη Cache. Για να εκτιμήσει τον συνολικό χρόνο πρόσβασης της Caches, η AtomicSimpleCPU χρησιμοποιεί τα latencyestimates από τα atomicaccesses.

**TimingSimpleCPU**** :**

Παρόμοια, αυτό το μοντέλο αποτελεί μια έκδοση της SimpleCPU, αλλά διαφέρει καθώς χρησιμοποιεί χρονικές προσβάσεις μνήμης. Επίσης, καθυστερεί τις προσβάσεις στη μνήμη Cache και περιμένει για το σύστημα μνήμης να αποκριθεί, πριν προχωρήσει στην αποστολή της επόμενης.

Default

|
                             | **MinorCPU** | **TimingSimpleCPU** |
                                   | --- | --- | --- |
| _Number of Ticks_              | 45767000 | 63736000 |
| _Sim\_seconds_                 | 0.000046 | 0.000064 |
| _Number of CPU cycles_            | 91534 | 127472 |
| _Number of Instructions Commited_ | 23914 | 23759 |
| _CPI: cycles per instruction_  | 3.827632 | Δεν υπάρχει στο αρχείο, αλλά με μια διαίρεση προκύπτει 5.365209 |
                  
                  
                             --sys-clock=400000000|
                             | **MinorCPU** | **TimingSimpleCPU** |
                                   | --- | --- | --- |
| _Number of Ticks_              | 57403000 | 74527500 |
| _Sim\_seconds_                 | 0.000057 | 0.000075 |
| _Number of CPU cycles_           | 114806 | 149055 |
| _Number of Instructions Commited_ | 23914 | 23759 |
| _CPI: cycles per instruction_  | 4.800786 | Δεν υπάρχει στο αρχείο, αλλά με μια διαίρεση προκύπτει 6.273623 |


                             --mem-type=DDR4\_2400\_8x8|
                             | **MinorCPU** | **TimingSimpleCPU** |
                                   | --- | --- | --- |
| _Number of Ticks_              | 44503000 | 63637000 |
| _Sim\_seconds_                 | 0.000045 | 0.000064 |
| _Number of CPU cycles_            | 89006 | 127274 |
| _Number of Instructions Commited_ | 23914 | 23759 |
| _CPI: cycles per instruction_   | 3.72192 | Δεν υπάρχει στο αρχείο, αλλά με μια διαίρεση προκύπτει 5.356875 |



Όπως παρατηρούμε, σε όλες τις περιπτώσεις ο MinorCPU τρέχει πιο γρήγορα από τον TimingSimpleCPU (sim\_seconds) και αυτό μπορούμε να το αποδώσουμε στο γεγονός ότι στον MinorCPU υπάρχει το pipeline, συνεπώς δεν χρειάζεται να περιμένει να τελειώσει η προσπέλαση της μνήμης πριν συνεχίσει στην επόμενη εντολή. Η ίδια παρατήρηση γίνεται και από τον αριθμό των ticks σε κάθε περίπτωση.

Ο αριθμός των instructions και στα δύο μοντέλα είναι σχεδόν ίδιος. Αντίθετα ο αριθμός των CPUcycles έχει μια αισθητή διαφορά και αυτό οφείλεται στο ότι ο TimingSimpleCPU χρησιμοποιεί timingmemoryaccess, άρα χρειάζονται περισσότεροι κύκλοι.
 Όταν αλλάζουμε την συχνότητα από το 1GHz σε 0.4GHz παρατηρούμε ότι αυξάνονται ο αριθμός των ticks, ο χρόνος εκτέλεσης και ο αριθμός των CPUcycles. Τέτοιο αποτέλεσμα είναι απολύτως λογικό.
 Τέλος με την αλλαγή της τεχνολογίας της μνήμης σε DDR4, αναμένουμε όλα τα νούμερα να είναι μικρότερα, κάτι το οποίο επαληθεύεται από τις πειραματικές μετρήσεις.
 Ο αριθμός των Instructions παρατηρούμε ότι δεν αλλάζει, όταν αλλάζουμε τις ρυθμίσεις, καθώς το τι πρέπει να εκτελεστεί εξαρτάται μόνο από το πρόγραμμα και όχι από τη συχνότητα και τον τύπο της μνήμης.

**Αξιολόγηση εργασίας**

Για την εργασία χρειάστηκα αρκετό χρόνο, κυρίως επειδή δεν έχω μεγάλη εμπειρία από linux. Η διαδικασία του να φτιάξω και να ρυθμίσω το VM, τον gem5 και ότι επιπλέον χρειάζεται ήταν αρκετά επεξηγηματική στο pdf της εργασίας και όλα κύλησαν ομαλά. Στα ερωτήματα πρώτου μέρους, δυσκολεύτηκα και παρατήρησα ότι υπήρχαν κάποια λάθη (κυρίως τυπογραφικά) και ασάφειες στην εργασία που μου κόστισαν πολύ χρόνο, καθώς δεν μου ήταν κατευθείαν εμφανές το τι φταίει. Όταν όμως κατάφερα και δούλεψαν όλα, μου άρεσε η όλη διαδικασία και πιστεύω έμαθα καινούργια πράγματα για τα linux, για τα μοντέλα επεξεργαστών αλλά και για το github.

 Μια συμβουλή που θα έδινα θα ήταν, να γίνει λίγο πιο επεξηγηματικό και το κομμάτι των ερωτημάτων και να μην θεωρούνται δεδομένα όλα τα προ απαιτούμενα. Σε πολλά ερωτήματα δεν καταλάβαινα τι ακριβώς πρέπει να επιλέξω να συγκρίνω από ένα αρχείο με πάρα πολλές γραμμές. Επίσης αν γίνεται, θα βοηθούσε πολύ να ανέβουν κάποιες «πρότυπες» απαντήσεις ή να μας πείτε κάποιο πλήρες github αρχείο κάποιο συμφοιτητή μας, για να μπορέσουμε να δούμε ποιές ήταν οι πλήρεις απαντήσεις.

 Συνολικά, ήταν μια ενδιαφέρον, ωραία αλλά λίγο χρονοβόρα άσκηση.




## **ΠΗΓΕΣ:**

[http://www.gem5.org/documentation/general\_docs/cpu\_models/SimpleCPU](http://www.gem5.org/documentation/general_docs/cpu_models/SimpleCPU)

[http://www.gem5.org/documentation/general\_docs/cpu\_models/minor\_cpu](http://www.gem5.org/documentation/general_docs/cpu_models/minor_cpu)
