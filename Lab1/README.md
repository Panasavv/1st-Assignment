ΑΡΙΣΤΟΤΕΛΕΙΟ ΠΑΝΕΠΙΣΤΗΜΙΟ ΘΕΣΣΑΛΟΝΙΚΗΣ

ΠΟΛΥΤΕΧΝΙΚΗ ΣΧΟΛΗ

ΤΜΗΜΑ ΗΛΕΚΤΡΟΛΟΓΩΝ ΜΗΧΑΝΙΚΩΝ &amp; ΜΗΧΑΝΙΚΩΝ ΥΠΟΛΟΓΙΣΤΩΝ

# Αρχιτεκτονική Προηγμένων Υπολογιστών - 1η Εργαστηριακή Άσκηση

## Απάντηση ερώτησης 1

### Διαθέσιμοι τύποι CPU:
 i) Atomic Simple CPU
 ii) Minor CPU
 iii) HPI CPU

Από τις παραπάνω CPU τελικά χρησιμοποιήσαμε την **MinorCPU**, η οποία είναι μια απλή,
in-order CPU με fixed pipeline. Τα χαρακτηριστικά του συστήματος έχουν ως εξής:

* Τάση συστήματος: **3.3V**
* Συχνότητα ρολογιού CPU: **4GHz**
* Συχνότητα ρολογιού συστήματος: **1GHz**
* Τάση πυρήνα: **1.2V**
* Αριθμός πυρήνων: **1**


### Caches

Εφόσον επιλέξαμε την Minor CPU θα έχουμε **L1** και **L2** caches, με τις
ιδιότητες που φαίνονται παρακάτω. Καθώς το αρχείο `starter_se.py` δεν περιέχει
πληροφορίες περί μεγέθους και associativity των cache, εκτός από τα ονόματα των
κλάσεων της Python που τις ορίζουν (γραμμές 66-69). Οι κλάσεις καθεαυτές μπορούν
να βρεθούν στο αρχείο `devices.py`, το οποίο βρίσκεται στον ίδιο φάκελο με το
`starter_se.py`.

* Μέγεθος γραμμής: **64 bytes**
* L1 instruction cache: **48 kB, 3-way-associative**
* L1 data cache: **32 kB, 2-way-associative**
* L2 cache: **1 MB, 16-way-associative**


### Μνήμη

Στην εντολή που τρέξαμε δεν προσδιορίσαμε κάτι για την μνήμη (μέσω της εντολής –mem)
συνεπώς θα ληφθούν οι default τιμές: 
* Τύπος μνήμης: **DDR3\_1600\_8x8** (DDR3 1600 MHz)
* Κανάλια: **2**
* Μέγεθος μνήμης: **2GB**
* Δίαυλος (bus): **SystemXBar()**


## Απάντηση ερώτησης 2a

Σύμφωνα με το αρχείο `config.ini` που δημιουργήθηκε από τον gem5, οι παραπάνω
παράμετροι συστήματος μπορούν να επιβεβαιωθούν από τις τιμές του αρχείου αυτού,
όπως στον ακόλουθο πίνακα:

| Στοιχείο             | Σχετική μεταβλητή | Τομέας στο αρχείο `config.ini`           | Τιμή μεταβλητής    |
|----------------------|-------------------|------------------------------------------|--------------------|
| Αριθμός πυρήνων      |     numThreads    | system.cpu_cluster.cpus                  | 1                  |
| Συχνότητα ρολ. συστ. |       clock       | system.clk_domain                        | 1000 (ticks)       |
| Τάση τροφοδ. συστ.   |      voltage      | system.voltage_domain                    | 3.3 (V)            |
| Τύπος CPU            |        type       | system.cpu_cluster.cpus                  | MinorCPU           |
| Συχνότ. ρολογ. CPU   |       clock       | system.cpu_cluster.clk_domain            | 250 (ticks)        |
| Τάση πυρήνα CPU      |      voltage      | system.cpu_cluster.voltage_domain        | 1.2 (V)            |
| Μέγεθος RAM          |     mem_ranges    | system                                   | 2147483648 (bytes) |
| Τύπος RAM            |                   |                                          |                    |
| Μέγεθος γρ. cache    | cache\_line\_size | system                                   | 64 (bytes)         |
| Μέγ. L1 instr. cache |        size       | system.cpu_cluster.cpus.icache           | 49152 (bytes)      |
| Τύπος L1 inst. cache |       assoc       | system.cpu_cluster.cpus.icache           | 3 (ways)           |
| Μέγ. L1 data cache   |        size       | system.cpu_cluster.cpus.dcache           | 32768 (bytes)      |
| Τύπος L1 data cache  |       assoc       | system.cpu_cluster.cpus.dcache           | 2 (ways)           |
| Μέγ. L2 cache        |        size       | system.cpu_cluster.l2                    | 1048576 (bytes)    |
| Τύπος L2 cache       |       assoc       | system.cpu_cluster.l2                    | 16 (ways)          |

## Απάντηση ερώτησης 2b

Με βάση τα αποτελέσματα στο αρχείο `stats.txt`, ο αριθμός των committed instruction για το
εκτελέσιμο `hello` είναι **5028**. (μεταβλητή `system.cpu.committedInsts`). Παρατηρούμε ότι
ο αριθμός των εκτελεσθέντων πράξεων είναι **5834** (μεταβλητή `sim_ops`). Η διαφορά προκύπτει
από το γεγονός ότι οι εντολές που στέλνονται προς τη CPU για εκτέλεση δεν έχουν 1-προς-1
αντιστοιχία με τα πραγματικά "micro-operations" που εκτελεί ο επεξεργαστής στο υλικό του.
Με άλλα λόγια, μία εντολή από την ISA της CPU μπορεί να απαιτεί παραπάνω από ένα micro-operation
για να εκτελεστεί.


## Απάντηση ερώτησης 2c

Ο συνολικός αριθμός προσπελάσεων της **L2 cache** προκύπτει από τη μεταβλητή 
`system.cpu_cluster.l2.demand_accesses::total` και είναι ίσος με **479**.
Σε περίπτωση που η πληροφορία αυτή δεν δινόταν από τον gem5, θα μπορούσε να υπολογιστεί
από το άθροισμα των τιμών στις μεταβλητές `system.cpu_cluster.cpus.icache.overall_mshr_misses::total` 
**(332)** και `system.cpu_cluster.cpus.dcache.overall_mshr_misses::total` **(147)** , νούμερο που συνάδει 
με το **479** που βρήκαμε παραπάνω. Οι μεταβλητές αυτές αναπαριστούν τον αριθμό των συνολικών misses της 
instruction cache και data cache αντίστοιχα, τα οποία αναζητούνται μετά στην L2 cache.



**3.**

**MinorCPU**** :**
 Αυτό το μοντέλο CPU, όπως μας ζητήθηκε, είναι ένα in-order μοντέλο επεξεργαστή. Χρησιμοποιείται κυρίως διότι επιτρέπει την οπτικοποίηση της θέσης μιας εντολής μέσα στο pipeline διαμέσω του MinorTrace/minorview.pyformat/tool. Η MinorCPU χρησιμοποιείται για να προσομοιώνει μοντέλα επεξεργαστών με αυστηρή in-order εκτέλεση και να παρέχει μια δομή για μικρο-αρχιτεκτονική συσχέτιση του μοντέλου με μια συγκεκριμένη διαδικασία, όπως έχουμε επιλέξει, που έχει παρόμοιες δυνατότητες με αυτήν που χρησιμοποιούμε.

**AtomicSimpleCPU**** :**
 Το μοντέλο αυτό αποτελεί μια version της SimpleCPU η οποία χρησιμοποιεί atomicmemoryaccesses. Η AtomicSimpleCPU επιλέγει ποια θύρα θα χρησιμοποιήσει έτσι ώστε να έρθει σε επαφή με τη μνήμη και να ενώσει την CPU με την μνήμη Cache. Για να εκτιμήσει τον συνολικό χρόνο πρόσβασης της Caches, η AtomicSimpleCPU χρησιμοποιεί τα latencyestimates από τα atomicaccesses.

**TimingSimpleCPU**** :**

Παρόμοια, αυτό το μοντέλο αποτελεί μια έκδοση της SimpleCPU, αλλά διαφέρει καθώς χρησιμοποιεί χρονικές προσβάσεις μνήμης. Επίσης, καθυστερεί τις προσβάσεις στη μνήμη Cache και περιμένει για το σύστημα μνήμης να αποκριθεί, πριν προχωρήσει στην αποστολή της επόμενης.

Default

|
                             | **MinorCPU** | **TimingSimpleCPU** |

| _Number of Ticks_              | 45767000 | 63736000 |

| _Sim\_seconds_                 | 0.000046 | 0.000064 |

| _Number of CPU cycles_            | 91534 | 127472 |

| _Number of Instructions Commited_ | 23914 | 23759 |

| _CPI: cycles per instruction_  | 3.827632 | Δεν υπάρχει στο αρχείο, αλλά με μια διαίρεση προκύπτει 5.365209 |
                  
                  
                             --sys-clock=400000000
|
                             | **MinorCPU** | **TimingSimpleCPU** |

| _Number of Ticks_              | 57403000 | 74527500 |

| _Sim\_seconds_                 | 0.000057 | 0.000075 |

| _Number of CPU cycles_           | 114806 | 149055 |

| _Number of Instructions Commited_ | 23914 | 23759 |

| _CPI: cycles per instruction_  | 4.800786 | Δεν υπάρχει στο αρχείο, αλλά με μια διαίρεση προκύπτει 6.273623 |


                             --mem-type=DDR4\_2400\_8x8
|
                             | **MinorCPU** | **TimingSimpleCPU** |

| _Number of Ticks_              | 44503000 | 63637000 |

| _Sim\_seconds_                 | 0.000045 | 0.000064 |

| _Number of CPU cycles_            | 89006 | 127274 |

| _Number of Instructions Commited_ | 23914 | 23759 |

| _CPI: cycles per instruction_   | 3.72192 | Δεν υπάρχει στο αρχείο, αλλά με μια διαίρεση προκύπτει 5.356875 |



Όπως παρατηρούμε, σε όλες τις περιπτώσεις ο MinorCPU τρέχει πιο γρήγορα από τον TimingSimpleCPU (sim\_seconds) και αυτό μπορούμε να το αποδώσουμε στο γεγονός ότι στον MinorCPU υπάρχει το pipeline, συνεπώς δεν χρειάζεται να περιμένει να τελειώσει η προσπέλαση της μνήμης πριν συνεχίσει στην επόμενη εντολή. Η ίδια παρατήρηση γίνεται και από τον αριθμό των ticks σε κάθε περίπτωση.

Ο αριθμός των instructions και στα δύο μοντέλα είναι σχεδόν ίδιος. Αντίθετα ο αριθμός των CPUcycles έχει μια αισθητή διαφορά και αυτό οφείλεται στο ότι ο TimingSimpleCPU χρησιμοποιεί timingmemoryaccess, άρα χρειάζονται περισσότεροι κύκλοι.
 Όταν αλλάζουμε την συχνότητα από το 1GHz σε 0.4GHz παρατηρούμε ότι αυξάνονται ο αριθμός των ticks, ο χρόνος εκτέλεσης και ο αριθμός των CPUcycles. Τέτοιο αποτέλεσμα είναι απολύτως λογικό.
 Τέλος με την αλλαγή της τεχνολογίας της μνήμης σε DDR4, αναμένουμε όλα τα νούμερα να είναι μικρότερα, κάτι το οποίο επαληθεύεται από τις πειραματικές μετρήσεις.
 Ο αριθμός των Instructions παρατηρούμε ότι δεν αλλάζει, όταν αλλάζουμε τις ρυθμίσεις, καθώς το τι πρέπει να εκτελεστεί εξαρτάται μόνο από το πρόγραμμα και όχι από τη συχνότητα και τον τύπο της μνήμης.

**Αξιολόγηση εργασίας**

Για την εργασία χρειάστηκα αρκετό χρόνο, κυρίως επειδή δεν έχω μεγάλη εμπειρία από linux. Η διαδικασία του να φτιάξω και να ρυθμίσω το VM, τον gem5 και ότι επιπλέον χρειάζεται ήταν αρκετά επεξηγηματική στο pdf της εργασίας και όλα κύλησαν ομαλά. Στα ερωτήματα πρώτου μέρους, δυσκολεύτηκα και παρατήρησα ότι υπήρχαν κάποια λάθη (κυρίως τυπογραφικά) και ασάφειες στην εργασία που μου κόστισαν πολύ χρόνο, καθώς δεν μου ήταν κατευθείαν εμφανές το τι φταίει. Όταν όμως κατάφερα και δούλεψαν όλα, μου άρεσε η όλη διαδικασία και πιστεύω έμαθα καινούργια πράγματα για τα linux, για τα μοντέλα επεξεργαστών αλλά και για το github.

 Μια συμβουλή που θα έδινα θα ήταν, να γίνει λίγο πιο επεξηγηματικό και το κομμάτι των ερωτημάτων και να μην θεωρούνται δεδομένα όλα τα προ απαιτούμενα. Σε πολλά ερωτήματα δεν καταλάβαινα τι ακριβώς πρέπει να επιλέξω να συγκρίνω από ένα αρχείο με πάρα πολλές γραμμές. Επίσης αν γίνεται, θα βοηθούσε πολύ να ανέβουν κάποιες «πρότυπες» απαντήσεις ή να μας πείτε κάποιο πλήρες github αρχείο κάποιο συμφοιτητή μας, για να μπορέσουμε να δούμε ποιές ήταν οι πλήρεις απαντήσεις.

 Συνολικά, ήταν μια ενδιαφέρον, ωραία αλλά λίγο χρονοβόρα άσκηση.




## **ΠΗΓΕΣ:**

[http://www.gem5.org/documentation/general\_docs/cpu\_models/SimpleCPU](http://www.gem5.org/documentation/general_docs/cpu_models/SimpleCPU)

[http://www.gem5.org/documentation/general\_docs/cpu\_models/minor\_cpu](http://www.gem5.org/documentation/general_docs/cpu_models/minor_cpu)
